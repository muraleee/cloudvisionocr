// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using ParseVisionJSON;
//
//    var welcome = Welcome.FromJson(jsonString);

namespace ParseVisionJSON
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Welcome
    {
        [JsonProperty("inputConfig")]
        public InputConfig InputConfig { get; set; }

        [JsonProperty("responses")]
        public List<Response> Responses { get; set; }
    }

    public partial class InputConfig
    {
        [JsonProperty("gcsSource")]
        public GcsSource GcsSource { get; set; }

        [JsonProperty("mimeType")]
        public string MimeType { get; set; }
    }

    public partial class GcsSource
    {
        [JsonProperty("uri")]
        public string Uri { get; set; }
    }

    public partial class Response
    {
        [JsonProperty("fullTextAnnotation")]
        public FullTextAnnotation FullTextAnnotation { get; set; }

        [JsonProperty("context")]
        public Context Context { get; set; }
    }

    public partial class Context
    {
        [JsonProperty("uri")]
        public string Uri { get; set; }

        [JsonProperty("pageNumber")]
        public long PageNumber { get; set; }
    }

    public partial class FullTextAnnotation
    {
        [JsonProperty("pages")]
        public List<Page> Pages { get; set; }

        [JsonProperty("text")]
        public string Text { get; set; }
    }

    public partial class Page
    {
        [JsonProperty("property")]
        public PageProperty Property { get; set; }

        [JsonProperty("width")]
        public long Width { get; set; }

        [JsonProperty("height")]
        public long Height { get; set; }

        [JsonProperty("blocks")]
        public List<Block> Blocks { get; set; }
    }

    public partial class Block
    {
        [JsonProperty("boundingBox")]
        public BoundingBox BoundingBox { get; set; }

        [JsonProperty("paragraphs")]
        public List<Paragraph> Paragraphs { get; set; }

        [JsonProperty("blockType")]
        public BlockType BlockType { get; set; }

        [JsonProperty("confidence")]
        public double Confidence { get; set; }
    }

    public partial class BoundingBox
    {
        [JsonProperty("normalizedVertices")]
        public List<NormalizedVertex> NormalizedVertices { get; set; }
    }

    public partial class NormalizedVertex
    {
        [JsonProperty("x")]
        public double X { get; set; }

        [JsonProperty("y")]
        public double Y { get; set; }
    }

    public partial class Paragraph
    {
        [JsonProperty("boundingBox")]
        public BoundingBox BoundingBox { get; set; }

        [JsonProperty("words")]
        public List<Word> Words { get; set; }

        [JsonProperty("confidence")]
        public double Confidence { get; set; }
    }

    public partial class Word
    {
        [JsonProperty("property", NullValueHandling = NullValueHandling.Ignore)]
        public WordProperty Property { get; set; }

        [JsonProperty("boundingBox")]
        public BoundingBox BoundingBox { get; set; }

        [JsonProperty("symbols")]
        public List<Symbol> Symbols { get; set; }

        [JsonProperty("confidence")]
        public double Confidence { get; set; }
    }

    public partial class WordProperty
    {
        [JsonProperty("detectedLanguages")]
        public List<PurpleDetectedLanguage> DetectedLanguages { get; set; }
    }

    public partial class PurpleDetectedLanguage
    {
        [JsonProperty("languageCode")]
        public LanguageCode LanguageCode { get; set; }
    }

    public partial class Symbol
    {
        [JsonProperty("property", NullValueHandling = NullValueHandling.Ignore)]
        public SymbolProperty Property { get; set; }

        [JsonProperty("text")]
        public string Text { get; set; }

        [JsonProperty("confidence")]
        public double Confidence { get; set; }
    }

    public partial class SymbolProperty
    {
        [JsonProperty("detectedLanguages", NullValueHandling = NullValueHandling.Ignore)]
        public List<PurpleDetectedLanguage> DetectedLanguages { get; set; }

        [JsonProperty("detectedBreak", NullValueHandling = NullValueHandling.Ignore)]
        public DetectedBreak DetectedBreak { get; set; }
    }

    public partial class DetectedBreak
    {
        [JsonProperty("type")]
        public TypeEnum Type { get; set; }
    }

    public partial class PageProperty
    {
        [JsonProperty("detectedLanguages")]
        public List<FluffyDetectedLanguage> DetectedLanguages { get; set; }
    }

    public partial class FluffyDetectedLanguage
    {
        [JsonProperty("languageCode")]
        public LanguageCode LanguageCode { get; set; }

        [JsonProperty("confidence")]
        public double Confidence { get; set; }
    }

    public enum BlockType { Text };

    public enum LanguageCode { En, Pt };

    public enum TypeEnum { EolSureSpace, LineBreak, Space };

    public partial class Welcome
    {
        public static Welcome FromJson(string json) => JsonConvert.DeserializeObject<Welcome>(json, ParseVisionJSON.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Welcome self) => JsonConvert.SerializeObject(self, ParseVisionJSON.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                BlockTypeConverter.Singleton,
                LanguageCodeConverter.Singleton,
                TypeEnumConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class BlockTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BlockType) || t == typeof(BlockType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "TEXT")
            {
                return BlockType.Text;
            }
            throw new Exception("Cannot unmarshal type BlockType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BlockType)untypedValue;
            if (value == BlockType.Text)
            {
                serializer.Serialize(writer, "TEXT");
                return;
            }
            throw new Exception("Cannot marshal type BlockType");
        }

        public static readonly BlockTypeConverter Singleton = new BlockTypeConverter();
    }

    internal class LanguageCodeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LanguageCode) || t == typeof(LanguageCode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "en":
                    return LanguageCode.En;
             
                default:
                    return LanguageCode.En;
            }
            throw new Exception("Cannot unmarshal type LanguageCode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LanguageCode)untypedValue;
            switch (value)
            {
                case LanguageCode.En:
                    serializer.Serialize(writer, "en");
                    return;
                case LanguageCode.Pt:
                    serializer.Serialize(writer, "pt");
                    return;
            }
            throw new Exception("Cannot marshal type LanguageCode");
        }

        public static readonly LanguageCodeConverter Singleton = new LanguageCodeConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EOL_SURE_SPACE":
                    return TypeEnum.EolSureSpace;
                case "LINE_BREAK":
                    return TypeEnum.LineBreak;
                case "SPACE":
                    return TypeEnum.Space;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.EolSureSpace:
                    serializer.Serialize(writer, "EOL_SURE_SPACE");
                    return;
                case TypeEnum.LineBreak:
                    serializer.Serialize(writer, "LINE_BREAK");
                    return;
                case TypeEnum.Space:
                    serializer.Serialize(writer, "SPACE");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }
}
